/* qbt-config.sample: This file is an example qbt-config file.
 *
 * The qbt-config file is a groovy file that returns a QbtConfig object when
 * evaluated.  The QbtConfig object can be customized to accomplish a wide
 * variety of things, but primarily it tells qbt where to store repo and
 * artifact caches, and where to find pins
 *
 * Settings you may want to change are marked with //KNOB
 * Settings you MUST set are marked with //TODO
 */
import com.google.common.collect.ImmutableList;
import java.nio.file.Paths;
import qbt.artifactcacher.CompoundArtifactCacher;
import qbt.artifactcacher.LocalArtifactCacher;
import qbt.config.CompoundQbtRemoteFinder;
import qbt.config.FormatLocalRepoFinder;
import qbt.config.FormatQbtRemoteFinder;
import qbt.config.MapQbtRemoteFinder;
import qbt.config.QbtConfig;
import qbt.pins.SimpleLocalPinsRepo;
import qbt.remote.FormatQbtRemote;
import qbt.remote.GithubQbtRemote;
import qbt.vcs.VcsRegistry;


def dotQbt = Paths.get(System.getenv("HOME")).resolve(".qbt"); //KNOB: this is where QBT will store its cache.
def gitRemoteVcs = VcsRegistry.getRawRemoteVcs("git");
def gitLocalVcs = gitRemoteVcs.getLocalVcs();
//def token = new File('/home/cmyers/.github-api-token').text.trim(); //KNOB: if you want to use a GithubQbtRemote, fill this in with your github API token.  This is only needed to create repositories, push and pull use your ssh key.


return new QbtConfig( //KNOB: if you are setting QBT up for use in an enterprise, you can extend QbtConfig with MyCompanyQbtConfig that sets all the defaults, making this file effectively 1-2 lines.

/* The FormatLocalRepoFinder tells QBT where to put your overrides (i.e. local
 * checkouts of repositories you are working on).  This default will simply
 * place them "next to" your checkout of meta, making the directory that
 * contains the meta checkout effectively the root of your workspace.  For best
 * results, you probably want to put a .qbt-meta-location file in that
 * directory as well.
 *
 * Note:  Something fancy is going on here.  By setting the environment
 * variable "NO_OVERRIDES=1", we can temporarily disable overrides.  This is a
 * handy trick!
 */ 
     new FormatLocalRepoFinder(
         gitLocalVcs,
         workspaceRoot.resolve(System.getenv("NO_OVERRIDES") ? "/dev/null" : "../%r").toString(), //KNOB: where to put overrides
     ),

/* The SimpleLocalPinsRepo object tells QBT where to put your pins.  Pins are
 * git refs for the various sattelite repositories referred to in your
 * manifest.  They function as a cache of the repositories.  It is safe to use
 * the same pin cache across all workspaces, because for any single pushPins
 * only the pins in your qbt-manifest are sent.  If you wanted to, however, you
 * could still use a per-workspace pins directory.  The default below makes a
 * shared one in your .qbt directory.
 */
     new SimpleLocalPinsRepo(
         gitRemoteVcs,
         dotQbt.resolve("pins/v1"),
     ),

/* The QbtRemote interface tells QBT how to find pins in git remotes.  Here we
 * demonstrate how to create a list of several remotes which can be used just
 * like git remotes.
 *
 * CompoundQbtRemoteFinder: Takes a list of QbtRemotes, and tries each one in series
 * MapQbtRemoteFinder: takes a map of "name" to QbtRemote impls
 *
 * FormatQbtRemote: Simplest remote, takes a git URL with "%r" substituted in for repository name (optionally).
 *
 * GithubQbtRemote: Similar to FormatQbtRemote but github specific, this impl can "autovivify" repositories as well, if they do not exist, on push.
 *
 */
     new CompoundQbtRemoteFinder([
         new MapQbtRemoteFinder([
/* //TODO: you must configure your own remote in order to pushPins anywhere.  You can use a FormatQbtRemote or a GithubQbtRemote as the examples below show.
             origin: new FormatQbtRemote(
                 gitRemoteVcs,
                 "ssh://git@git.example.com/somerepo/%r.git"
             ),
*/
             cmyers: new GithubQbtRemote( //KNOB: you may want to remove these, they are here so you can pull from the QBT core devs.
                gitRemoteVcs,
                null,
                "TerabyteQbt",
            ),
             amling: new GithubQbtRemote(
                gitRemoteVcs,
                null,
                "AmlingQbt",
            ),
         ]),
         new FormatQbtRemoteFinder( //KNOB: this is optional, but having it lets you put a raw URL straight into the command like, e.g. "qbt fetchPins ssh://git@git.example.com/foo/%r.git"
             gitRemoteVcs,
         ),
     ]),

/* The CompoundArtifactCacher lets you configure artifact caching.  This is how
 * QBT stores artifacts after building them, and finds already-built artifacts
 * to avoid rebuilding them.  There are ArtifactCacher implementations
 * available which support remote (shared across machine) caches as well.
 */
     new CompoundArtifactCacher(
         ImmutableList.of(
             new LocalArtifactCacher(
                 dotQbt.resolve("artifacts/v1"), //KNOB: where to put the artifact cache
                 5L * (1024 * 1024 * 1024) //KNOB: how big to let the artifact cache grow to (default: 5GB)
             ),
         ),
     ),
 );

// vi: ft=java
